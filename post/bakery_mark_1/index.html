<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>My first lightmap baker: Bakery - LimZtudio</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="My first lightmap baker: Bakery" />
<meta property="og:description" content="A simple Sponza Palace baked by my first lightmap baker. Only one directional light and Skylight(ambient light) setup in the scene. Looking pretty rough. 
It&rsquo;s been a couple of years. Since I started making my own lightmap baker.
And before I start this article, I finished this project. Although I need a lot of things to do: such as optimization, complete some minor features and fix many bugs&hellip;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://limztudio.github.io/post/bakery_mark_1/" />
<meta property="article:published_time" content="2020-03-13T22:23:10+09:00" />
<meta property="article:modified_time" content="2020-03-13T22:23:10+09:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My first lightmap baker: Bakery"/>
<meta name="twitter:description" content="A simple Sponza Palace baked by my first lightmap baker. Only one directional light and Skylight(ambient light) setup in the scene. Looking pretty rough. 
It&rsquo;s been a couple of years. Since I started making my own lightmap baker.
And before I start this article, I finished this project. Although I need a lot of things to do: such as optimization, complete some minor features and fix many bugs&hellip;"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="LimZtudio" rel="home">
				<div class="logo__title">LimZtudio</div>
				<div class="logo__tagline">Render-Land</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About me</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">My first lightmap baker: Bakery</h1>
			<p class="post__lead">A note about my struggle while I was making my first lightmap baker.</p>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2020-03-13T22:23:10&#43;09:00">2020-03-13</time>
</div>

<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/developement/" rel="category">Developement</a>
	</span>
</div></div>
		</header><div class="content post__content clearfix">
			<p><br/><br/>



<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/sponza.png"
    alt="Sponza"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
A simple Sponza Palace baked by my first lightmap baker. Only one directional light and Skylight(ambient light) setup in the scene. Looking pretty rough.
</div>
<br/><br/></p>
<p>It&rsquo;s been a couple of years. Since I started making my own lightmap baker.<br>
And before I start this article, I finished this project. Although I need a lot of things to do: such as optimization, complete some minor features and fix many bugs&hellip;<br>
But now I&rsquo;m planning to make a Mark.II of it. Because I judged here are too many things to be changed. Also, I won&rsquo;t use radiosity anymore. Instead, I will use raytrace with monte carlo method for my next project.</p>
<p>Anyway, here&rsquo;s how I created it.</p>
<br/><br/>
<h2 id="at-the-beginning">At the beginning</h2>
<p>Let&rsquo;s go back to when I started this project.<br>
I got a request that our game needs indirect lighting technique to make it looks fancier.<br>
And at that time, I don&rsquo;t have any knowledge of indirect light. So I had no idea where do I start it.<br>
But thankfully, one of my bosses told me a keyword. <em><strong>Radiosity</strong></em>.</p>
<p>So the first I read was <a href="https://en.wikipedia.org/wiki/Radiosity_(computer_graphics)">Radiosity on Wikipedia</a>. Then I could learn how it working. But still, needed something more detail or an actual example of implementation.<br>
And I found <a href="https://mynameismjp.wordpress.com/2011/01/31/radiosity-dx11-style/">Radiosity, DX11 style</a>. It described how to calculate irradiance(On here, it&rsquo;s a result of radiosity calculation) in every vertex, and bake them using <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">Spherical harmonics</a> to store in each vertex.<br>
But in my case, irradiance needed to be calculated in every texel of each object. So I decided I better make it possible to store in texels first.</p>
<br/><br/>
<h2 id="find-sample-points">Find sample points</h2>
<p>Unlike using &lsquo;vertex as sample point&rsquo;(what I call sample point is a point that calculates irradiance by its position and normal direction, then stores them), &lsquo;texel as sample point&rsquo; need to be found where is their position and normal direction along their UV coordinate.</p>
<p>So my idea to find out each sample point was:</p>
<blockquote>
<ol>
<li>Give a specific size of a segment. The number of sample points on an object surface will depend on this segment size.</li>
<li>Multiply each UV position by the segment size. The result of each UV position(let&rsquo;s call this &lsquo;vertex on pixel&rsquo;) will be a position on its lightmap in pixel.</li>
<li>Connect every &lsquo;vertex on pixel&rsquo; by their index(vertex order). Then you will get polygons on their lightmap(and let&rsquo;s call this &lsquo;polygon on pixel&rsquo;).</li>
<li>Put each &lsquo;polygon on pixel&rsquo; on a grid whose distance from a line to line is 1 pixel.</li>
<li>Now you can see an intersection between every &lsquo;polygon on pixel&rsquo; and 1x1 squares made by the grid.</li>
<li>Find every centroid in every polygon made by the intersection.</li>
<li>Convert every centroid to 3D space. You can earn the position and normal direction of each sample point.</li>
</ol>
</blockquote>
<p>And <em>Figure 01</em> is how are the steps I described working on:<br>



<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure01.gif"
    alt="Figure01"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 01: A flow of find sample points in 2D(UV) space. The green points are the each of &#39;vertex on pixel&#39;. The red squares are intersections. And the black points are the centroids to be calculated by sample point on 3D space.
</div>
<br/><br/></p>
<p>Then next I thought was how do I come up with an algorithm to find out these centroids on the UV space.<br>
And after few times of attempt, I got an idea:</p>
<blockquote>
<p>It&rsquo;s quite simple. Guess the segment size is 32.<br>
Then let&rsquo;s start off making a 32x32 square on the UV space.</p>
<ol>
<li>Check if the box(square) and triangle(polygon on pixel) are intersected. And the result of the intersection can be expressed by these four:
<ul>
<li>Triangle contains box</li>
<li>Box contains triangle</li>
<li>They&rsquo;re intersected</li>
<li>Nothing intersected</li>
</ul>
</li>
<li>If the triangle contains the box, every 1x1 square in the box is contained by the triangle.<br>
Therefore, chop the box in every 1x1 square. Then calculate the centroid of each square.</li>
<li>If the box contains the triangle or they&rsquo;re just intersected, chop the box in half and back to step 1. Then perform this procedure again for chopped two boxes.<br>
And if the box has a larger height than width, chop it in a horizontal direction. Or else, chop it in a vertical direction.</li>
<li>If nothing intersected between them, you can finish this loop.</li>
<li>If the box size became 1x1, you can also finish this loop. After doing this following subsequential steps:
<ul>
<li>If the triangle contains the box, calculate the centroid of the box.</li>
<li>If the box contains the triangle, calculate the centroid of the triangle.</li>
<li>If they&rsquo;re just intersected, find a &lsquo;generated polygon&rsquo;(which is generated by the intersection between them). and calculate its centroid.</li>
</ul>
</li>
</ol>
</blockquote>
<p>And here&rsquo;s <em>Figure 02</em>. As I mentioned, when the boxes chopped in half, the chopped two boxes need to perform the above procedure individually. But I depicted only one of the box here for an explanation. 



<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure02.gif"
    alt="Figure02"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 02: A flow of find centroids. The yellow squares are the current search region. The black squares are discarded region. And black points are the centroids.
</div>
<br/><br/></p>
<p>Also, I remembered <a href="https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm">Sutherland–Hodgman algorithm</a>. To find out the &lsquo;generated polygon&rsquo; between interested two polygons.<br>
On the article, they referred that if the subject polygon is concave, the output &lsquo;generated polygon&rsquo; may have extraneous lines. Since it has only one vertex list output. So somehow this may cause a problem to find out centroid depending on an algorithm.<br>
But luckily, the subject polygon here always be a triangle, so it will never be concaved.</p>
<p>And here is a C++ like pseudo-code of my idea. I used <a href="https://software.intel.com/en-us/tbb">Intel® TBB library</a>. Which allowed me easily parallelize my code. Because it has its own task scheduler.<br>
If you&rsquo;re working with <strong>MVSC</strong>, you can use <strong>PPL</strong>(since <strong>MVSC 2010</strong>) instead of <strong>TBB</strong> library. Seems mostly it&rsquo;s possible to switch between them. Though it looks like <strong>TBB</strong> has more extra features than <strong>PPL</strong>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;tbb/task_group.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
...

Triangles triangles;
Centroids centroids;

tbb<span style="color:#f92672">::</span>task_group worker;

...

Polygon calculateIntersectGeneratedPolygon(<span style="color:#66d9ef">const</span> Polygon<span style="color:#f92672">&amp;</span> clipPolygon, <span style="color:#66d9ef">const</span> Polygon<span style="color:#f92672">&amp;</span> subjectPolygon){
    <span style="color:#75715e">// use Sutherland–Hodgman algorithm to calculate the &#39;generated polygon&#39;.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// mind you that the &#39;subjectPolygon&#39; will be clipped by each side of the &#39;clipPolygon&#39;.
</span><span style="color:#75715e"></span>    ...
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">collectCentroidsInTriangle</span>(
                                <span style="color:#66d9ef">const</span> Triangle<span style="color:#f92672">&amp;</span> triangle,
                                <span style="color:#66d9ef">unsigned</span> left,
                                <span style="color:#66d9ef">unsigned</span> top,
                                <span style="color:#66d9ef">unsigned</span> right,
                                <span style="color:#66d9ef">unsigned</span> bottom
                                )
{
    Box box(left, top, right, bottom);
    
    <span style="color:#75715e">// the &#39;state&#39; can be expressed by:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// &#34;triangle contains box&#34;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// &#34;box contains triangle&#34;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// &#34;they&#39;re intersected&#34;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// &#34;nothing intersected&#34;
</span><span style="color:#75715e"></span>    IntersectState state <span style="color:#f92672">=</span> box.intersect(triangle);
    
    <span style="color:#75715e">// if the &#39;box&#39; has 1x1 of size, you can&#39;t chop it anymore.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(box.width <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> box.height <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
        <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;triangle contains box&#34;</span>){
            centroids.add(box.calCentroid());
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;box contains triangle&#34;</span>){
            centroids.add(triangle.calCentroid());
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;they&#39;re intersected&#34;</span>){
            <span style="color:#75715e">// find a polygon generated by the intersection between &#39;box&#39; and &#39;triangle&#39;.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// then calculate its centroid.
</span><span style="color:#75715e"></span>            centroids.add(calculateIntersectGeneratedPolygon(box, triangle).calCentroid());
        }
    }
    <span style="color:#66d9ef">else</span>{
        <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;triangle contains box&#34;</span>){
            <span style="color:#75715e">// chop &#39;box&#39; in every 1x1 square.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// then calculate the centroid of each square.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> y <span style="color:#f92672">=</span> top; y <span style="color:#f92672">&lt;</span> bottom; <span style="color:#f92672">++</span>y){
                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> x <span style="color:#f92672">=</span> left; x <span style="color:#f92672">&lt;</span> right; <span style="color:#f92672">++</span>x){
                    Box boxLocal(x, y, x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
                    
                    centroids.add(boxLocal.calCentroid());
                }
            }
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;box contains triangle&#34;</span> <span style="color:#f92672">||</span> state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;they&#39;re intersected&#34;</span>){
            <span style="color:#75715e">// chop current &#39;box&#39; in half and execute this function again.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// if the &#39;box&#39; has a larger height than width, chop it in a horizontal direction.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// or else, chop it in a vertical direction.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(box.height <span style="color:#f92672">&gt;</span> box.width){
                worker.run([<span style="color:#f92672">&amp;</span>]{
                    collectCentroidsInTriangle(triangle, left, top, right, (top <span style="color:#f92672">+</span> bottom) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
                    });
                worker.run([<span style="color:#f92672">&amp;</span>]{
                    collectCentroidsInTriangle(triangle, left, (top <span style="color:#f92672">+</span> bottom) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, right, bottom);
                    });
            }
            <span style="color:#66d9ef">else</span>{
                worker.run([<span style="color:#f92672">&amp;</span>]{
                    collectCentroidsInTriangle(triangle, left, top, (left <span style="color:#f92672">+</span> right) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, bottom);
                    });
                worker.run([<span style="color:#f92672">&amp;</span>]{
                    collectCentroidsInTriangle(triangle, (left <span style="color:#f92672">+</span> right) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, top, right, bottom);
                    });
            }
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">collectCentroidsInTriangles</span>(<span style="color:#66d9ef">unsigned</span> segmentSize){
    <span style="color:#75715e">// scale UV coordinate by segmentSize
</span><span style="color:#75715e"></span>    triangles.setSegment(segmentSize);
    
    <span style="color:#75715e">// since multiple triangles can exist in the same object,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// you need to iterate all triangles in the object.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(cosnt Triangle<span style="color:#f92672">&amp;</span> triangle : triangles){
        unsinged minX, minY, maxX, maxY;
        
        <span style="color:#75715e">// find min/max UV coordinate of each &#39;triangle&#39;
</span><span style="color:#75715e"></span>        triangle.findMinMax(<span style="color:#f92672">&amp;</span>minX, <span style="color:#f92672">&amp;</span>minY, <span style="color:#f92672">&amp;</span>maxX, <span style="color:#f92672">&amp;</span>maxY);
        
        worker.run([<span style="color:#f92672">&amp;</span>]{
            collectCentroidsInTriangle(triangle, minX, minY, maxX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, maxY <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
            });
    }
}

...

<span style="color:#66d9ef">int</span> main(){
    ...
    triangles.init();
    centroids.init();
    
    collectCentroidsInTriangles(<span style="color:#ae81ff">32</span>);
    
    <span style="color:#75715e">// wait for every task to complete
</span><span style="color:#75715e"></span>    worker.wait();
    ...
}
</code></pre></div><br/><br/>
<p>Now we have a couple of steps left to be ready to calculate irradiance.</p>
<br/><br/>
<h2 id="centroids-become-sample-points-in-3d-space">Centroids become sample points in 3D space</h2>
<p>We&rsquo;ve been watching how to find centroids in 2D space. And now it&rsquo;s time to convert these in 3D space to use them as an actual sample point.</p>
<p>And fortunately, there was a good tool to convert my centroids. it&rsquo;s called <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates">Barycentric coordinates</a>.<br>
According to the article(in the link above), it&rsquo;s possible to convert each centroid by down below:</p>
<blockquote>
<ol>
<li>Here you have a triangle \(\triangle ABC\).</li>
<li>And there&rsquo;s a point \(P\) which located inside the \(\triangle ABC\).</li>
<li>Then if you connect all the points \(A\), \(B\), \(C\) and \(P\), you will get 3 sub-triangles \(\triangle ABP\), \(\triangle ACP\) and \(\triangle BCP\).</li>
<li>And let&rsquo;s say, \(x = \frac{\triangle BCP _\rm{Area}}{\triangle ABC _\rm{Area}}\), \(y = \frac{\triangle ACP _\rm{Area}}{\triangle ABC _\rm{Area}}\) and \(z = \frac{\triangle ABP _\rm{Area}}{\triangle ABC _\rm{Area}}\). Then you can see \(x + y + z = 1\).</li>
<li>Finally, you can calculate \(P\) by the following: \(P = xA + yB + zC\).</li>
</ol>
</blockquote>
<p>So the first, when it comes to the current situation, the \(\triangle ABC\) represents each triangle of the object. And the \(P\) is each calculated centroid(note that this is not a centroid of \(\triangle ABC\). I&rsquo;m talking about the centroids that we&rsquo;ve calculated above.) in the triangle.<br>
Therefore, It is possible to find \(x\), \(y\) and \(z\) for each centroid.<br>
Also, you don&rsquo;t have to calculate every \(x\), \(y\) and \(z\) by calculating each area, but two of them. Since \(x + y + z = 1\).</p>
<p>And second, you would remember \(A\), \(B\) and \(C\) each point of the triangle are actually vertices of geometry in 3D space. And here just used its UV component of each vertex.<br>
So pretend \(A^\prime\), \(B^\prime\) and \(C^\prime\) are the position(in 3D space) component of each vertex.</p>
<p>Then finally, each centroid in 3D coordinate \(P^\prime\) is: \(P^\prime = xA^\prime + yB^\prime + zC^\prime\).<br>
Also, you can apply it in every component of the vertex. Such as the normal direction. But in this case, make sure to normalize after calculating \(P^\prime\).</p>
<br/><br/>
<h2 id="one-pixel-multiple-sample-points">One pixel, multiple sample points</h2>
<p>I briefly mentioned on the pseudo-code above that &lsquo;multiple triangles can exist in the same object&rsquo;.</p>
<p>And let&rsquo;s think about what will be happened if one more triangle is located in the same space.<br>
Probably, with a high chance, many pixels will contain one more centroid. And one of the common cases you can see it happens is a &lsquo;rectangle&rsquo;.</p>
<p>As you know, every single primitive are expressed by a sequence of triangles. Hence, the rectangle is not an exemption. More exactly, the rectangle is made up of two triangles.</p>
<p>Then where will it be? Which spot have multiple centroids in the rectangle? You would intuitively notice, it&rsquo;s a diagonal side of the rectangle.<br>
The diagonal side of the rectangle, in other words, is a spot that one edge on each side of two triangles is ovelapped.<br>
And the edge also crosses the pixels. See <em>Figure 03</em>.</p>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure03.gif"
    alt="Figure03"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 03: The rectangle on a UV(2D) space. Pixels are each grid. And the orange and red points are the centroids generated by intersecting the rectangle and pixels. You can observe two centroids on each spot where the diagonal side of each triangle crosses pixels.
</div>
<br/><br/></p>
<p>We just saw the case two centroids are placed in one pixel. But then again, there are so many possibilities that more than two centroids placing in one pixel. Depending on how the triangles allocated.</p>
<br/><br/>
<h2 id="one-pixel-multiple-sample-points-whats-the-matter">One pixel, multiple sample points: What&rsquo;s the matter?</h2>
<p>Then, I asked myself what is the actual problem if each irradiance is stored in the same pixel. To solve this problem, I needed to remember how I use lightmap.
The final result of lightmap that I&rsquo;m gonna make will be used as texture when primitives in a scene are rendered.<br>
So if multiple irradiances are stored in a pixel, it will cause an unexpected(or weird looking) result when a shader samples the position of the pixel while rendering primitives.</p>
<p>But there was one more thing I had to remember. I said it will cause an unexpected result. But somehow it will be pretty expected. What I meant is, every triangle in the UV space, I pretended <strong>they&rsquo;re not overlapped each other</strong>(figure. how UV is pelted in 3ds max).<br>
And that means, for the sample points that each of their irradiances are needed to be stored in the same place, they will be quite close together in 3D space. So I instantly thought if I calculate an average position for the overlapped sample points, then compare with the result between original and this one.</p>
<p>And this is how I calculate irradiance in both original and average position.</p>
<p>The original:</p>
<blockquote>
<ol>
<li>Calculate irradiance on each sample point.</li>
<li>Calculate the area of each polygon whose centroid in 3D space is each sample point.</li>
<li>Sum all the area in a pixel. And divide each area by this summation(I&rsquo;m gonna call it &lsquo;Participation rate&rsquo;).</li>
<li>Multiply each irradiance by each &lsquo;Participation rate&rsquo;. Then sum them together.</li>
<li>This summation is the irradiance of this pixel. (Weighted averaged irradiance)</li>
</ol>
</blockquote>
<p>The averaged position:</p>
<blockquote>
<ol>
<li>Calculate the area of each polygon whose centroid in 3D space is each sample point.</li>
<li>Add all the area in a pixel. And divide each area by this summation(This is &lsquo;Participation rate&rsquo; which is the same thing above).</li>
<li>Multiply position and normal of each sample point by each &lsquo;Participation rate&rsquo;. Then sum each position and normal separately.
Also, don&rsquo;t forget to normalize the &lsquo;summation of normals&rsquo;.</li>
<li>Shoot a ray &lsquo;summation of normals&rsquo; direction at the &lsquo;summation of positions&rsquo;. And test if there are any intersections between the polygons which are belonging with current pixel.</li>
<li>Find the farthest intersection. That is a new sample point position of the current pixel.</li>
<li>If there is nothing intersected, Shoot a ray negative &lsquo;summation of normals&rsquo; direction at the same point. And samely, test if there are any intersections between the polygons which are belonging with current pixel.</li>
<li>Find the nearest intersection. That is the new sample point position of the current pixel.</li>
<li>If nothing intersected still, &lsquo;summation of positions&rsquo; is the new sample point position of the current pixel.</li>
<li>Calculate irradiance with &lsquo;summation of normals&rsquo; at the new sample point position.</li>
</ol>
</blockquote>
<p>And thankfully there was not much difference between them.</p>
<br/><br/>
<h2 id="references">References</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Radiosity_(computer_graphics)">Radiosity on Wikipedia</a></li>
<li><a href="https://mynameismjp.wordpress.com/2011/01/31/radiosity-dx11-style/">Radiosity, DX11 style, by MJP</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm">Sutherland–Hodgman algorithm on Wikipedia</a></li>
<li><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates">Barycentric coordinates by Scratchapixel</a></li>
<li><a href="https://web.archive.org/web/20160511192712/http://freespace.virgin.net/hugo.elias/radiosity/radiosity.htm">Radiosity, by Hugo Elias</a></li>
<li><a href="http://public.beuth-hochschule.de/~godberse/wiese/cga1/08_3Dglobal/sw/radiosity/radiosity_all.htm">Radiosity OverView</a></li>
</ul>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item"><a class="tags__link btn" href="/tags/developement/" rel="tag">Developement</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/rendering/" rel="tag">Rendering</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/radiosity/" rel="tag">Radiosity</a></li>
	</ul>
</div>
		</footer>
	</article>
</main>


<script src="https://utteranc.es/client.js"
        repo="limztudio/blog_comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

			</div>
			<aside class="sidebar">
<div class="widget-categories widget">
	<h4 class="widget__title">Categories</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item">
				<a class="widget__link" href="/categories/developement/">Developement</a>
			</li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/developement/" title="Developement">Developement</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/radiosity/" title="Radiosity">Radiosity</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/rendering/" title="Rendering">Rendering</a>
	</div>
</div>
<div class="widget-social widget">
	<h4 class="widget-social__title widget__title">Social</h4>
	<div class="widget-social__content widget__content">
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="Email" href="mailto:limztudio@gmail.com">
				<svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16-256-16h-16-384-16zm347 16-139 92.5-139-92.5zm-148 125.5 9 5.5 9-5.5 167-111.5v210h-352v-210z"/></svg>
				<span>limztudio@gmail.com</span>
			</a>
		</div>

		
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 LimZtudio.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>