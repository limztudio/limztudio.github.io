<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>My first lightmap baker: Bakery - LimZtudio</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="My first lightmap baker: Bakery" />
<meta property="og:description" content="A simple Sponza Palace baked by my first lightmap baker. Only one directional light and Skylight(ambient light) setup in the scene. Looking pretty rough. 
 And the lightmap of the whole scene above. It has an information of both direct light and indirect light colour.  
It&rsquo;s been a couple of years. Since I started making my own lightmap baker.
And before I start this article, I finished this project." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://limztudio.github.io/post/bakery_mark_1/" />
<meta property="article:published_time" content="2020-03-13T22:23:10+09:00" />
<meta property="article:modified_time" content="2020-03-13T22:23:10+09:00" />

	
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="LimZtudio" rel="home">
				<div class="logo__title">LimZtudio</div>
				<div class="logo__tagline">Render-Land</div>
			</a>
		</div>
		
<nav class="menu">
	<button class="menu__btn" aria-haspopup="true" aria-expanded="false" tabindex="0">
		<span class="menu__btn-title" tabindex="-1">Menu</span>
	</button>
	<ul class="menu__list">
		<li class="menu__item">
			<a class="menu__link" href="/about/">
				
				<span class="menu__text">About me</span>
				
			</a>
		</li>
	</ul>
</nav>

	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">My first lightmap baker: Bakery</h1>
			<p class="post__lead">A note about my struggle while I was making my first lightmap baker.</p>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2020-03-13T22:23:10&#43;09:00">2020-03-13</time>
</div>

<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/developement/" rel="category">Developement</a>
	</span>
</div></div>
		</header><div class="content post__content clearfix">
			<p><br/><br/>



<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/sponza.png"
    alt="Sponza"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
A simple Sponza Palace baked by my first lightmap baker. Only one directional light and Skylight(ambient light) setup in the scene. Looking pretty rough.
</div>
<br/><br/></p>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/sponza_lightmap.png"
    alt="Sponza_lightmap"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
And the lightmap of the whole scene above. It has an information of both direct light and indirect light colour. 
</div>
<br/><br/></p>
<p>It&rsquo;s been a couple of years. Since I started making my own lightmap baker.<br>
And before I start this article, I finished this project. Although I need a lot of things to do: such as optimization, complete some minor features and fix many bugs&hellip;<br>
But now I&rsquo;m planning to make a Mark.II of it. Because I judged here are too many things to be changed. Also, I won&rsquo;t use radiosity anymore. Instead, I will use raytrace with monte carlo method for my next project.</p>
<p>Anyway, here&rsquo;s how I created it.</p>
<br/><br/>
<h2 id="at-the-beginning">At the beginning</h2>
<p>Let&rsquo;s go back to when I started this project.<br>
I got a request that our game needs indirect lighting technique to make it looks fancier.<br>
And at that time, I don&rsquo;t have any knowledge of indirect light. So I had no idea where do I start it.<br>
But thankfully, one of my bosses told me a keyword. <em><strong>Radiosity</strong></em>.</p>
<p>So the first I read was <a href="https://en.wikipedia.org/wiki/Radiosity_(computer_graphics)">Radiosity on Wikipedia</a>. Then I could learn how it working. But still, needed something more detail or an actual example of implementation.<br>
And I found <a href="https://mynameismjp.wordpress.com/2011/01/31/radiosity-dx11-style/">Radiosity, DX11 style</a>. It described how to calculate irradiance(On here, it&rsquo;s the result of radiosity calculation) in every vertex, and bake them using <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">Spherical harmonics</a> to store in each vertex.<br>
But in my case, irradiance needed to be calculated in every texel of each object. So I decided I better make it possible to store in texels first.</p>
<br/><br/>
<h2 id="find-sample-points">Find sample points</h2>
<p>Unlike using <strong>vertex as sample point</strong>(what I call sample point is a point that calculates irradiance by its position and normal direction, then stores them), <strong>texel as sample point</strong> need to be found where is their position and normal direction along their UV coordinate.</p>
<p>So my idea to find out each sample point was:</p>
<blockquote>
<ol>
<li>Give a specific size of segment. The number of sample points on the object surface will depend on this segment size.</li>
<li>Multiply each UV position by the segment size. The result of each UV position(let&rsquo;s call this <strong>vertex on pixel</strong>) will be a position of its lightmap in pixel.</li>
<li>Connect every <strong>vertex on pixel</strong> by their index(vertex order). Then you will get polygons on their lightmap(and let&rsquo;s call this <strong>polygon on pixel</strong>).</li>
<li>Put each <strong>polygon on pixel</strong> on a grid whose distance from line to line is 1 pixel.</li>
<li>Now you can see an intersection between every <strong>polygon on pixel</strong> and 1x1 squares made by the grid.</li>
<li>Find every centroid in every polygon made by the intersection.</li>
<li>Convert every centroid to 3D space. You will earn position and normal direction of each sample point.</li>
</ol>
</blockquote>
<p>And <em>Figure 01</em> is how are the steps I described working on:<br>



<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure01.gif"
    alt="Figure01"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 01: A flow of finding sample points in 2D(UV) space. The green points are each of **vertex on pixel**. The red squares are intersections. And the black points are the centroids to be calculated by sample point on 3D space.
</div>
<br/><br/></p>
<p>Then next I thought was how do I come up with an algorithm to find out these centroids on the UV space.<br>
And after few times of attempt, I got an idea:</p>
<blockquote>
<p>It&rsquo;s quite simple. Guess the segment size is 32.<br>
Then let&rsquo;s start off making 32x32 square on the UV space.</p>
<ol>
<li>Check if a box(square) and a triangle(<strong>polygon on pixel</strong>) are intersected. And the result of intersection can be expressed by these four:
<ul>
<li>Triangle contains box</li>
<li>Box contains triangle</li>
<li>They&rsquo;re intersected</li>
<li>Nothing intersected</li>
</ul>
</li>
<li>If the triangle contains the box, every 1x1 square in the box is contained by the triangle.<br>
Therefore, chop the box in every 1x1 square. Then calculate centroid of each square.</li>
<li>If the box contains the triangle or they&rsquo;re just intersected, chop the box in half and back to step 1. Then perform this procedure again for chopped two boxes.<br>
And if the box has larger height than width, chop it in horizontal direction. Or else, chop it in vertical direction.</li>
<li>If nothing intersected between them, this loop can be finished.</li>
<li>If the box size became 1x1, the loop also can be finished. But after doing this following subsequential steps:
<ul>
<li>If the triangle contains the box, calculate centroid of the box.</li>
<li>If the box contains the triangle, calculate centroid of the triangle.</li>
<li>If they&rsquo;re just intersected, find <strong>generated polygon</strong>(which is generated by the intersection between them). and calculate its centroid.</li>
</ul>
</li>
</ol>
</blockquote>
<p>And here&rsquo;s <em>Figure 02</em>. As I mentioned, when boxes chopped in half, chopped two boxes need to perform above procedure individually. But I depicted only one of the box here for explanation. 



<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure02.gif"
    alt="Figure02"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 02: A flow of finding centroids. The yellow squares are current searching region. The black squares are discarded region. And black points are centroids.
</div>
<br/><br/></p>
<p>Also, I remembered <a href="https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm">Sutherland–Hodgman algorithm</a> to find out <strong>generated polygon</strong> between intersected two polygons.<br>
On the article, they mentioned that if subject polygon is concave, the output <strong>generated polygon</strong> may have extraneous lines. Since it has only one vertex list output.<br>
But luckily, subject polygon here always be a triangle, so it will never be concaved.</p>
<p>And here is C++ like pseudo-code of my idea. I used <a href="https://software.intel.com/en-us/tbb">Intel® TBB library</a>. Which allowed me easily parallelize my code. Because it has its own task scheduler.<br>
If you&rsquo;re working with <strong>MVSC</strong>, you don&rsquo;t necessarily have to integrate <strong>TBB</strong>. As an alternate, you can use a built-in library called <a href="https://docs.microsoft.com/cpp/parallel/concrt/parallel-patterns-library-ppl">PPL</a>(since <strong>MVSC 2010</strong>) which has almost the same interface with <strong>TBB</strong>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;tbb/task_group.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
...

Triangles triangles;
Centroids centroids;

tbb<span style="color:#f92672">::</span>task_group worker;

...

Polygon calculateIntersectGeneratedPolygon(<span style="color:#66d9ef">const</span> Polygon<span style="color:#f92672">&amp;</span> clipPolygon, <span style="color:#66d9ef">const</span> Polygon<span style="color:#f92672">&amp;</span> subjectPolygon){
    <span style="color:#75715e">// use Sutherland–Hodgman algorithm to calculate &#39;generated polygon&#39;.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// mind you that &#39;subjectPolygon&#39; will be clipped by each side of &#39;clipPolygon&#39;.
</span><span style="color:#75715e"></span>    ...
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">collectCentroidsInTriangle</span>(
                                <span style="color:#66d9ef">const</span> Triangle<span style="color:#f92672">&amp;</span> triangle,
                                <span style="color:#66d9ef">unsigned</span> left,
                                <span style="color:#66d9ef">unsigned</span> top,
                                <span style="color:#66d9ef">unsigned</span> right,
                                <span style="color:#66d9ef">unsigned</span> bottom
                                )
{
    Box box(left, top, right, bottom);
    
    <span style="color:#75715e">// the &#39;state&#39; can be expressed by:
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// &#34;triangle contains box&#34;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// &#34;box contains triangle&#34;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// &#34;they&#39;re intersected&#34;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// &#34;nothing intersected&#34;
</span><span style="color:#75715e"></span>    IntersectState state <span style="color:#f92672">=</span> box.intersect(triangle);
    
    <span style="color:#75715e">// if &#39;box&#39; has 1x1 of size, you can&#39;t chop it anymore.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(box.width <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> box.height <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>){
        <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;triangle contains box&#34;</span>){
            centroids.add(box.calCentroid());
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;box contains triangle&#34;</span>){
            centroids.add(triangle.calCentroid());
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;they&#39;re intersected&#34;</span>){
            <span style="color:#75715e">// find polygon generated by intersection between &#39;box&#39; and &#39;triangle&#39;.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// then calculate its centroid.
</span><span style="color:#75715e"></span>            centroids.add(calculateIntersectGeneratedPolygon(box, triangle).calCentroid());
        }
    }
    <span style="color:#66d9ef">else</span>{
        <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;triangle contains box&#34;</span>){
            <span style="color:#75715e">// chop &#39;box&#39; in every 1x1 square.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// then calculate centroid of each square.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> y <span style="color:#f92672">=</span> top; y <span style="color:#f92672">&lt;</span> bottom; <span style="color:#f92672">++</span>y){
                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> x <span style="color:#f92672">=</span> left; x <span style="color:#f92672">&lt;</span> right; <span style="color:#f92672">++</span>x){
                    Box boxLocal(x, y, x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
                    
                    centroids.add(boxLocal.calCentroid());
                }
            }
        }
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;box contains triangle&#34;</span> <span style="color:#f92672">||</span> state <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;they&#39;re intersected&#34;</span>){
            <span style="color:#75715e">// chop current &#39;box&#39; in half and execute this function again.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// if &#39;box&#39; has larger height than width, chop it in horizontal direction.
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// or else, chop it in vertical direction.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(box.height <span style="color:#f92672">&gt;</span> box.width){
                worker.run([<span style="color:#f92672">&amp;</span>]{
                    collectCentroidsInTriangle(triangle, left, top, right, (top <span style="color:#f92672">+</span> bottom) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
                    });
                worker.run([<span style="color:#f92672">&amp;</span>]{
                    collectCentroidsInTriangle(triangle, left, (top <span style="color:#f92672">+</span> bottom) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, right, bottom);
                    });
            }
            <span style="color:#66d9ef">else</span>{
                worker.run([<span style="color:#f92672">&amp;</span>]{
                    collectCentroidsInTriangle(triangle, left, top, (left <span style="color:#f92672">+</span> right) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, bottom);
                    });
                worker.run([<span style="color:#f92672">&amp;</span>]{
                    collectCentroidsInTriangle(triangle, (left <span style="color:#f92672">+</span> right) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>, top, right, bottom);
                    });
            }
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">collectCentroidsInTriangles</span>(<span style="color:#66d9ef">unsigned</span> segmentSize){
    <span style="color:#75715e">// scale UV coordinate by segmentSize
</span><span style="color:#75715e"></span>    triangles.setSegment(segmentSize);
    
    <span style="color:#75715e">// since multiple triangles can exist in the same object,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// you need to iterate all triangles in the object.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">const</span> Triangle<span style="color:#f92672">&amp;</span> triangle : triangles){
        unsinged minX, minY, maxX, maxY;
        
        <span style="color:#75715e">// find min/max UV coordinate of each &#39;triangle&#39;
</span><span style="color:#75715e"></span>        triangle.findMinMax(<span style="color:#f92672">&amp;</span>minX, <span style="color:#f92672">&amp;</span>minY, <span style="color:#f92672">&amp;</span>maxX, <span style="color:#f92672">&amp;</span>maxY);
        
        worker.run([<span style="color:#f92672">&amp;</span>]{
            collectCentroidsInTriangle(triangle, minX, minY, maxX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, maxY <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
            });
    }
}

...

<span style="color:#66d9ef">int</span> main(){
    ...
    triangles.init();
    centroids.init();
    
    collectCentroidsInTriangles(<span style="color:#ae81ff">32</span>);
    
    <span style="color:#75715e">// wait for every task to complete
</span><span style="color:#75715e"></span>    worker.wait();
    ...
}
</code></pre></div><br/><br/>
<p>Now we have a couple of steps left to be ready to calculate irradiance.</p>
<br/><br/>
<h2 id="centroids-become-sample-points-in-3d-space">Centroids become sample points in 3D space</h2>
<p>We&rsquo;ve been watching how to find centroids in 2D space. And now it&rsquo;s time to convert these in 3D space to use them as an actual sample point.</p>
<p>And fortunately, there was a good tool to convert my centroids. it&rsquo;s called <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates">Barycentric coordinates</a>.<br>
According to the article in the link above, it&rsquo;s possible to convert each centroid by down below:</p>
<blockquote>
<ol>
<li>Here you have a triangle \(\triangle ABC\).</li>
<li>And there&rsquo;s a point \(P\) which placed inside the \(\triangle ABC\).</li>
<li>Then if you connect all the points \(A\), \(B\), \(C\) and \(P\), you will get 3 sub-triangles \(\triangle ABP\), \(\triangle ACP\) and \(\triangle BCP\).</li>
<li>And let&rsquo;s say, \(x = \frac{\triangle BCP _\rm{Area}}{\triangle ABC _\rm{Area}}\), \(y = \frac{\triangle ACP _\rm{Area}}{\triangle ABC _\rm{Area}}\) and \(z = \frac{\triangle ABP _\rm{Area}}{\triangle ABC _\rm{Area}}\). Then you can see \(x + y + z = 1\).</li>
<li>Finally, you can calculate \(P\) by the following: \(P = xA + yB + zC\).</li>
</ol>
</blockquote>
<p>So the first, when it comes to the current situation, the \(\triangle ABC\) represents each triangle of the object. And the \(P\) is each calculated centroid(note that this is not a centroid of \(\triangle ABC\). I&rsquo;m talking about the centroids that we&rsquo;ve calculated above.) in the triangle.<br>
Therefore, It is possible to find \(x\), \(y\) and \(z\) for each centroid.<br>
Also, you don&rsquo;t have to calculate every \(x\), \(y\) and \(z\) by calculating each area, but two of them. Since \(x + y + z = 1\).</p>
<p>And second, you would remember \(A\), \(B\) and \(C\) each point of the triangle are actually vertices of geometry in 3D space. And here just used its UV component of each vertex.<br>
So pretend \(A^\prime\), \(B^\prime\) and \(C^\prime\) are the position component in 3D space of each vertex.</p>
<p>Then finally, each centroid in 3D coordinate \(P^\prime\) is: \(P^\prime = xA^\prime + yB^\prime + zC^\prime\).<br>
Also, you can apply it in every component of the vertex. Such as normal direction. But in this case, make sure to normalize after calculating \(P^\prime\).</p>
<br/><br/>
<h2 id="one-pixel-multiple-sample-points">One pixel, multiple sample points</h2>
<p>I briefly mentioned on the pseudo-code above that <em>multiple triangles can exist in the same object</em>.</p>
<p>And let&rsquo;s think about what will be happened if more than one triangle placed in the same space.<br>
Probably, with a high chance, many pixels will contain more than one centroid. And one of the common cases you can see it happens is <strong>rectangle</strong>.</p>
<p>As you know, every single primitive are expressed by sequence of triangles. Hence, rectangle is not an exemption. More exactly, rectangle is made up of two triangles.</p>
<p>Then where will it be? Which spot have multiple centroids in rectangle? You would intuitively notice, it&rsquo;s diagonal side of rectangle.<br>
The diagonal side of rectangle, in other words, is a spot that one edge on each side of two triangles is overlapped.<br>
And the edge also crosses the pixels. See <em>Figure 03</em>.</p>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure03.gif"
    alt="Figure03"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 03: The rectangle on UV(2D) space. Pixels are each grid. And the orange and red points are centroids generated by intersecting the rectangle and pixels. You can observe two centroids on each spot where the diagonal side of each triangle crosses pixels.
</div>
<br/><br/></p>
<p>We just saw the case two centroids are placed in one pixel. But then again, there are so many possibilities that more than two centroids placing in one pixel. Depending on how the triangles allocated.</p>
<br/><br/>
<h3 id="one-pixel-multiple-sample-points-whats-the-matter">One pixel, multiple sample points: What&rsquo;s the matter?</h3>
<p>Then, I asked myself what is the actual problem if each irradiance is stored in the same pixel. To solve this problem, I needed to remember how I use lightmap.
The final result of lightmap that I&rsquo;m gonna make will be used as texture when primitives in a scene are rendered.<br>
So if multiple irradiances are stored in one pixel, it will cause an unexpected(or weird looking) result when shader samples the position of the pixel while rendering primitives.</p>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure04.gif"
    alt="Figure04"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 04: A lightmap UV of an object in a scene. You can see there is no overlapping or duplication between triangles.
</div></p>
<p>But there was one more thing I had to remember. I said it will cause an unexpected result. But somehow it will be pretty expected. What I meant is, every triangle in the UV space, I pretended <strong>they&rsquo;re not overlapped each other</strong>. See <em>Figure 04</em>.<br>
And that means, for sample points that each of their irradiances are needed to be stored in a same place, they will be quite close together in 3D space. So I instantly thought if I calculate average position for overlapped sample points, then compare with the result between original and this one.</p>
<p>And this is how I calculate irradiance in both original and average position.</p>
<p>The original:</p>
<blockquote>
<ol>
<li>Calculate irradiance of each sample point.</li>
<li>Calculate area of each polygon whose centroid in 3D space is each sample point.</li>
<li>Add all the area in the current pixel. And divide each area by this summation(I&rsquo;m gonna call it <strong>participation rate</strong>).</li>
<li>Multiply each irradiance by each <strong>participation rate</strong>. Then add them together.</li>
<li>This summation is the irradiance of the current pixel. (Weighted averaged irradiance)</li>
</ol>
</blockquote>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure05.gif"
    alt="Figure05"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 05: 3 triangles are placed in one pixel(see left illustration). Magenta arrows are normal directions of each sample point. Each colour of triangle is the irradiance of each sample point. The final colour is weighed average of each irradiance.
</div>
<br/><br/></p>
<p>The average position:</p>
<blockquote>
<ol>
<li>Calculate area of each polygon whose centroid in 3D space is each sample point.</li>
<li>Add all the area in the current pixel. And divide each area by this summation(This is <strong>participation rate</strong> which is the same one above).</li>
<li>Multiply position and normal direction of each sample point by each <strong>participation rate</strong>. Then sum each position and normal direction separately.
Also, don&rsquo;t forget to normalize the <strong>summation of normal directions</strong>.</li>
<li>Shoot ray at the <strong>summation of positions</strong> along <strong>summation of normal directions</strong>. And test if there are any intersections between polygons which are belonging with current pixel.</li>
<li>Find farthest intersection. That is new sample point position of current pixel.</li>
<li>If nothing intersected, Shoot ray at the same point along negative <strong>summation of normal directions</strong> direction. And samely, test if there are any intersections between polygons which are belonging with current pixel.</li>
<li>Find nearest intersection. That is new sample point position of current pixel.</li>
<li>If nothing intersected still, <strong>summation of positions</strong> is the new sample point position of current pixel.</li>
<li>Calculate irradiance with <strong>summation of normal directions</strong> at new sample point position.</li>
</ol>
</blockquote>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure06.gif"
    alt="Figure06"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 06: Magenta arrows are normal directions of each sample point. Red arrow is weighted average of each normal direction. The final colour is an irradiance of averaged normal direction.
</div>



<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure06_1.gif"
    alt="Figure06-1"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 06-1: Averaged position will not always be placed on a surface of the object. So it needs to be moved along averaged normal direction until the position contact to the object.
</div>
<br/><br/></p>
<p>And thankfully there was not much difference between two. Except when the segment size goes too small. In the worst case, every triangle in the object will be placed in the same pixel. And this may cause the obvious difference between two. But we have to notice that both original and averaged methods won&rsquo;t show up correct result in that case.</p>
<br/><br/>
<h2 id="direct-light-computation">Direct light computation</h2>
<p>Now it&rsquo;s time to jump into the actual calculation of lightmap.<br>
And this will be the first <strong>visibly observable</strong> work of the whole process.</p>
<p>The direct lighting itself is dead easy. And probably has no relation with the radiosity method.<br>
Because I did it with the traditional diffuse lighting. Which is usually called by <strong>Lambertian Shading</strong>. As you know, it&rsquo;s just done by calculating \(\cos\theta\) between surface normal direction \(N\) and negated incident light direction \(L\).<br>
Also, I added here a tiny process to calculate occlusion between light and surface. So this will make a shadow by other object or by even itself.</p>
<p>And this is a simple pseudo-code of direct light calculation.<br>
Code will check the occlusion between each light and each sample point. Then if something occluded, make current colour of sample point to zero. Or else, calculate diffuse colour using Lambertian shading depends on its light type(<em>e.g., Directional light or Point light</em>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> sample : samplePoints){
    sample.totalLight <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> light : lights){
        Ray rayBetween <span style="color:#f92672">=</span> calculateRay(light, sample);

        <span style="color:#66d9ef">bool</span> bOccluded <span style="color:#f92672">=</span> false;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> object : objects){
            <span style="color:#66d9ef">if</span>(object.intersect(rayBetween)){
                bOccluded <span style="color:#f92672">=</span> true;
                <span style="color:#66d9ef">break</span>;
            }
        }

        sample.totalLight <span style="color:#f92672">+=</span> bOccluded <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> light.calculateColorOf(sample);
    }
}
</code></pre></div><br/><br/>
<p>And <em>Figure 07</em> is a result of the code. I placed a box on the ground. Only one directional light setup in the scene. In order to observe the clear result, I didn&rsquo;t use texture filter to render the lightmap.</p>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure07.gif"
    alt="Figure07"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 07: A box on the ground. The black area is the shaded region by directional light.
</div>
<br/><br/></p>
<p>So the direct light calculation is easily done. But as you notice, there is an obvious aliasing. Of course in actual practice, I used the bilinear filter to render the lightmap. But still, it was hard to hide ziggy-zaggy pattern.<br>
See how it looks different compare to non filtered one.</p>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure08.gif"
    alt="Figure08"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 08: Comparison of non filtered and bilinear filtered rendering. Right one is the bilinear filtered.
</div>
<br/><br/></p>
<p>As you can see, there is the aliasing remains.<br>
And I thought the simplest way to reduce the aliasing is increasing lightmap size. Yet, it will take too much time to calculate.
So, for the halfway solution, I divided each sample into small pieces but only for the direct light calculation. Hence, the indirect light calculation will not be affected.</p>
<p>And I made a simple logic to divide them. Which is: <em>you would remember in the early stage, I converted each centroid to 3D space and that is the sample point. And for each centroid, they have their own polygon(if you don&rsquo;t remember, <a href="#find-sample-points">check here</a>). So, what I did is connect centroid with every vertex of the polygon and for each vertex, connect to their neighbour vertices. Then you will find <em><strong>sub-triangles in the polygon</strong></em>. Now, find all <em><strong>centroids of each sub-triangle</strong></em>, then convert them to the 3D space. That will be the sub-divided sample point for the direct light calculation.</em></p>
<p>Since each sub-divided sample point are placed in the same pixel, don&rsquo;t forget to divide by their area size of sub-divided polygon.</p>
<p>And the result of this is <em>Figure 09</em>.</p>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure09.gif"
    alt="Figure09"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 09: Image on the left is the result that calculates direct light on each sample point. The other one is the same but calculated on each sub-divided sample point.
</div>
<br/><br/></p>
<p>The edge part of the shaded region(especially diagonal side in the lightmap), they look like multi-sampled. And let&rsquo;s see what if the bilinear filter applied.</p>
<p>


<div class="center">
  <img
    src="https://github.com/limztudio/blog_radiosity_repo/raw/master/figure09_1.gif"
    alt="Figure09-1"
    decoding="async"
  />
</div>


<div style="text-align: center; font-style: italic;">
Figure 09-1: Same as Figure09, but the bilinear filter applied.
</div>
<br/><br/></p>
<p>Now we see the aliasing is a bit relieved.</p>
<br/><br/>
<h3 id="direct-light-computation-a-small-tweak-for-speed-up">Direct light computation: A small tweak for speed up</h3>
<p>While I writing this article, I randomly got an idea to improve calculating speed of direct light computation. But it is just an idea, not implemented. So I have to test it to my future work.</p>
<p>Anyway, What I think is that most pixels of the shaded region have the same value, except when they placed close to the unshaded region. Therefore, if a pixel has the same(or similar even) result as its nearby pixels, it doesn&rsquo;t have to be sub-divided.</p>
<p>So the estimation will be like this:</p>
<blockquote>
<ol>
<li>Calculate direct light on the sample points.</li>
<li>Iterate sample points and calculate difference with their neighbour pixels(sample points).</li>
<li>If the difference has a big enough number(threshold), sub-divide polygon of the sample point, and calculate direct light again.</li>
</ol>
</blockquote>
<p>But I&rsquo;m not sure will it be effective if direct light calculation contains point light, spot light or if it allows transparent/translucent material or caustic effect. If so, each sample point will have more chance to have different value with others even if they&rsquo;re in the shaded region.</p>
<br/><br/>
<h2 id="the-radiosity">The radiosity</h2>
<p>Now it&rsquo;s the time to look up how to calculate indirect light. And like I mentioned in the early stages, I used radiosity method to calculate them. The reason why I choose it is, well, this was the only keyword I could search for.</p>
<p>According to <a href="http://public.beuth-hochschule.de/~godberse/wiese/cga1/08_3Dglobal/sw/radiosity/radiosity_all.htm">the slide, Radiosity OverView</a>(see slide 5 in the page), the radiosity method has its basis in the theory of <strong>thermal radiation</strong>. So the theory applied here to describe light energy.</p>
<p>Anyway, the important part is its equation. And for the finite number \(n\) of surface, the equation is:</p>
<blockquote>
<p>\(B _\rm{i} = \textit{E} _\rm{i} + ρ _\rm{i} \sum _{j=1}^n {\textit{B} _\rm{j} \cdot \textit{F} _\rm{ij}}\)</p>
</blockquote>
<p>where:<br>
\(B _\rm{i} =\) radiosity of surface \(i\)<br>
\(E _\rm{i} =\) emissivity of surface \(i\)<br>
\(ρ _\rm{i} =\) reflectivity of surface \(i\)<br>
\(B _\rm{j} =\) radiosity of surface \(j\)<br>
\(F _\rm{ij} =\) form factor of surface \(j\) relative to surface \(i\)</p>
<p>As you see, the equation is recursive. Because the \(B _\rm{j}\) on the right side is the previous result of \(B _\rm{i}\).<br>
Also, the \(B _\rm{i}\) would be the irradiance we&rsquo;ve been looking for.<br>
The case of \(E _\rm{i}\) and \(ρ _\rm{i}\), I could leave these as a constant value or sort of configurable one that depends on its surface material.<br>
And there&rsquo;s one ne left which called <strong>form factor</strong>, \(F _\rm{ij}\). This stands for a relation between leaves and arrives energy. And the following equation shows how the form factor should be calculated.</p>
<blockquote>
<p>\(F _\rm{ij} = \frac{1}{\textit{A} _\rm{i}} \cdot \int _{\textit{A} _\rm{i}} {\int _{\textit{A} _\rm{j}} {\frac{\cos\theta _\rm{i} \cdot \cos\theta _\rm{j}}{\pi r^2} \textit{dA} _\rm{i} \textit{dA} _\rm{j}}}\)<br>
<em>(It will be better to see slide 7 of <a href="http://public.beuth-hochschule.de/~godberse/wiese/cga1/08_3Dglobal/sw/radiosity/radiosity_all.htm">this page</a>)</em></p>
</blockquote>
<p>Each letter is:<br>
\(A _\rm{i}\) and \(A _\rm{j}\) are areas of surface \(i\) and surface \(j\).<br>
\(\theta _\rm{i}\) is the angle between surface \(i\) normal direction and a direction towards surface \(i\) to surface \(j\).<br>
\(\theta _\rm{j}\) is the angle between surface \(j\) normal direction and a direction towards surface \(j\) to surface \(i\).<br>
The \(r\) is the distance between surface \(j\) and surface \(i\).</p>
<p>And based on the equation, I wrote a code like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> sample : samplePoints){
    sample.totalLight <span style="color:#f92672">=</span> directLightOfCurrentSample() <span style="color:#f92672">+</span> sample.emissivity;
    sample.emitLight <span style="color:#f92672">=</span> sample.totalLight;
}

<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">unsigned</span> bounce <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; bounce <span style="color:#f92672">&lt;</span> bounceCount; <span style="color:#f92672">++</span>bounce){
    Color totalEmitOfBounce <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> iSample : samplePoints){
        Color totalIncidentOfSample <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> jSample : samplePoints){
            <span style="color:#66d9ef">if</span>(iSample <span style="color:#f92672">==</span> jSample)
                <span style="color:#66d9ef">continue</span>;

            Color addLight <span style="color:#f92672">=</span> jSample.emitLight <span style="color:#f92672">*</span> jSample.reflectivity;
            addLight <span style="color:#f92672">*=</span> calFormFactor(iSample, jSample);

            totalIncidentOfSample <span style="color:#f92672">+=</span> addLight;
        }

        iSample.totalLight <span style="color:#f92672">+=</span> totalIncidentOfSample;
        iSample.emitLight <span style="color:#f92672">=</span> totalIncidentOfSample;

        totalEmitOfBounce <span style="color:#f92672">+=</span> totalIncidentOfSample;
    }

    <span style="color:#66d9ef">if</span>(isTooSmall(totalEmitOfBounce))
        <span style="color:#66d9ef">break</span>;
}
</code></pre></div><p>Just like the equation, the <strong>totalLight</strong> of sample point will be calculated with the previous result of radiosity.<br>
And the <strong>bounceCount</strong> is a configurable value. By increasing <strong>bounceCount</strong>, the final result will be accurate. The reason why I left this as configurable because light bouncing needs a bunch of calculation. It&rsquo;s literally too slow. Moreover, in most cases, there are only tiny differences after 3 or 4 times of bouncing calculation.<br>
The <strong>calFormFactor(&hellip;)</strong> will return 0.0 to 1.0 of value, hence the <strong>totalEmitOfBounce</strong> will keep decreasing in every iteration of bouncing. As a result, when <strong>totalEmitOfBounce</strong> nearly closed to zero, future bouncing iteration will be cancelled.</p>
<p>Apparently, there are plenty of ways to implement the radiosity method for lightmap baking, but I could start off with two different ways. The biggest difference between two is how to calculate the form factor. And I&rsquo;m going to review both ways. But before the start, each way have pros and cons. So I can&rsquo;t say which is better.</p>
<br/><br/>
<h3 id="sample-point-to-sample-point">Sample point to sample point</h3>
<p>The first way is visiting every sample points per every other sample points. What I&rsquo;m saying is, <em>guess we have a table which contains every sample point in a scene. Then we&rsquo;ll iterate all the sample point in the table. While iterating each sample point, we will also iterate all another sample points per each and calculate form factor with them.</em></p>
<p>As you see, it will take \(O(n^2)\) of time complexity where \(n\) stands for <em>the count of sample points</em>. But in general, it&rsquo;s quite hard to find the case that one sample point relates to every other sample points in the scene. Because the equation shows when an angle of sample point normal direction and the direction from the sample point to another has a value which smaller than 90° is the only case the form factor is valid. In other words, if two sample points are not in range of each other&rsquo;s hemisphere(their normal direction oriented) boundary, they don&rsquo;t need to be related.<br>
Also, if two sample points are too far away, it&rsquo;s okay to be ignored since the equation says form factor divided by \(r^2\).</p>
<p>And these are only work I&rsquo;ve applied to decrease the calculation time. I&rsquo;ve better to think of applying KD-Tree or something like that. To improve effectively.</p>
<br/><br/>
<h3 id="hemicube-form-factor">Hemicube form factor</h3>
<br/><br/>
<h2 id="references">References</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Radiosity_(computer_graphics)">Radiosity on Wikipedia</a></li>
<li><a href="https://mynameismjp.wordpress.com/2011/01/31/radiosity-dx11-style/">Radiosity, DX11 style, by MJP</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm">Sutherland–Hodgman algorithm on Wikipedia</a></li>
<li><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates">Barycentric coordinates by Scratchapixel</a></li>
<li><a href="https://web.archive.org/web/20160511192712/http://freespace.virgin.net/hugo.elias/radiosity/radiosity.htm">Radiosity, by Hugo Elias</a></li>
<li><a href="http://public.beuth-hochschule.de/~godberse/wiese/cga1/08_3Dglobal/sw/radiosity/radiosity_all.htm">Radiosity OverView</a></li>
</ul>

		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item"><a class="tags__link btn" href="/tags/developement/" rel="tag">Developement</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/rendering/" rel="tag">Rendering</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/radiosity/" rel="tag">Radiosity</a></li>
	</ul>
</div>
		</footer>
	</article>
</main>


<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/post/differenceof_fpu_and_simd/" rel="next"><span class="post-nav__caption">Next&thinsp;»</span><p class="post-nav__post-title">Different result between FPU and SIMD</p></a>
	</div>
</nav>
<script src="https://utteranc.es/client.js"
        repo="limztudio/blog_comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

			</div>
			<aside class="sidebar">
<div class="widget-categories widget">
	<h4 class="widget__title">Categories</h4>
	<div class="widget__content">
		<ul class="widget__list">
			<li class="widget__item">
				<a class="widget__link" href="/categories/developement/">Developement</a>
			</li>
		</ul>
	</div>
</div>
<div class="widget-taglist widget">
	<h4 class="widget__title">Tags</h4>
	<div class="widget__content">
		<a class="widget-taglist__link widget__link btn" href="/tags/developement/" title="Developement">Developement</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/radiosity/" title="Radiosity">Radiosity</a>
		<a class="widget-taglist__link widget__link btn" href="/tags/rendering/" title="Rendering">Rendering</a>
	</div>
</div>
<div class="widget-social widget">
	<h4 class="widget-social__title widget__title">Social</h4>
	<div class="widget-social__content widget__content">
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="Email" href="mailto:limztudio@gmail.com">
				<svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16-256-16h-16-384-16zm347 16-139 92.5-139-92.5zm-148 125.5 9 5.5 9-5.5 167-111.5v210h-352v-210z"/></svg>
				<span>limztudio@gmail.com</span>
			</a>
		</div>
		<div class="widget-social__item widget__item">
			<a class="widget-social__link widget__link btn" title="GitHub" rel="noopener noreferrer" href="https://github.com/limztudio" target="_blank">
				<svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0c-106.1 0-192 85.8-192 191.7 0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2 0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8 0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7 0 0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4 0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5 0 25.6-.2 46.3-.2 52.6 0 5.1 3.5 11.1 13.2 9.2 76.2-25.5 131.2-97.3 131.2-182 0-105.9-86-191.7-192-191.7z"/></svg>
				<span>GitHub</span>
			</a>
		</div>

		
	</div>
</div>
</aside>
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2020 LimZtudio.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</body>
</html>